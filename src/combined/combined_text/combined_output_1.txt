
-- /nextjs_oem_frontend/utils/cookies.ts --
'use client'

export async function waitForSessionCookie(timeout = 1000): Promise<boolean> {
  let waited = 0
  while (!document.cookie.includes('sessionid') && waited < timeout) {
    await new Promise((res) => setTimeout(res, 50))
    waited += 50
  }
  return document.cookie.includes('sessionid')
}


----------------------------------------


-- /nextjs_oem_frontend/utils/useRecentlyReauthenticated.ts --
import { useAuth } from '../auth/AuthContext'

export function useRecentlyReauthenticated(): boolean {
  const { user, methods, lastReauthenticatedAt } = useAuth()

  // ✅ Bypass reauth kalau user memang tidak punya password
  if (user && user.has_usable_password === false) {
    return true
  }

  const FIVE_MINUTES = 5 * 60 * 1000
  const reauthenticated = methods?.some(m => m.reauthenticated) || false

  if (reauthenticated) return true
  if (!lastReauthenticatedAt) return false

  return Date.now() - new Date(lastReauthenticatedAt).getTime() < FIVE_MINUTES
}


----------------------------------------


-- /nextjs_oem_frontend/utils/isConfigReady.ts --
import { ConfigType } from '../lib/allauth'

export function isConfigReady(config: ConfigType | null | undefined): boolean {
  return !!(
    config &&
    typeof config === 'object' &&
    Object.keys(config).length > 0 &&
    config.account?.authentication_method
  )
}


----------------------------------------


-- /nextjs_oem_frontend/utils/reauth.ts --
// utils/reauth.ts
import { useAuth } from "../auth/AuthContext"

export function useRecentlyReauthenticated(): boolean {
  const { user, methods, lastReauthenticatedAt } = useAuth()

  // ✅ Bypass reauth kalau user memang tidak punya password
  if (user && user.has_usable_password === false) {
    return true
  }

  const FIVE_MINUTES = 5 * 60 * 1000
  const reauthenticated = methods?.some((m) => m.reauthenticated) || false

  if (reauthenticated) return true
  if (!lastReauthenticatedAt) return false

  return Date.now() - new Date(lastReauthenticatedAt).getTime() < FIVE_MINUTES
}



----------------------------------------


-- /nextjs_oem_frontend/utils/upload.ts --
// utils/upload.ts
import { request } from "../lib/allauth"

export async function uploadImage(file: File): Promise<string> {
  const formData = new FormData()
  formData.append("file", file)

  const data = await request<{ url: string }>(
    "POST",
    "/blog/uploads/image/",
    formData
  )

  return data.url
}


----------------------------------------


-- /nextjs_oem_frontend/lib/django.ts --
// lib/django.ts
export function getCSRFToken(): string | null {
  if (typeof document === 'undefined') return null

  const getCookie = (name: string): string | null => {
    const cookies = document.cookie.split(';')
    for (const cookie of cookies) {
      const trimmed = cookie.trim()
      if (trimmed.startsWith(`${name}=`)) {
        return decodeURIComponent(trimmed.substring(name.length + 1))
      }
    }
    return null
  }

  return getCookie('csrftoken')
}



----------------------------------------


-- /nextjs_oem_frontend/lib/allauth.ts --
// lib/allauth.ts
import { getCSRFToken } from './django'

export const Client = Object.freeze({
  BROWSER: 'browser' as const
})

export const settings = {
  client: Client.BROWSER,
  baseUrl: `https://backend.oem-x.my.id/_allauth/${Client.BROWSER}/v1`,
  withCredentials: true
}

const ACCEPT_JSON = {
  accept: 'application/json'
}

export const AuthProcess = Object.freeze({
  LOGIN: 'login',
  CONNECT: 'connect',
})

export const URLs = Object.freeze({
  CSRF: '/auth/csrf',
  CONFIG: '/config',
  SESSION: '/auth/session',
  LOGIN: '/auth/login',
  LOGOUT: '/auth/session',
  SIGNUP: '/auth/signup',
  REAUTHENTICATE: '/auth/reauthenticate',
  VERIFY_EMAIL: '/auth/email/verify',
  REQUEST_PASSWORD_RESET: '/auth/password/request',
  RESET_PASSWORD: '/auth/password/reset',
  PROVIDER_SIGNUP: '/auth/provider/signup',
  REDIRECT_TO_PROVIDER: '/auth/provider/redirect',
  PROVIDER_TOKEN: '/auth/provider/token',
  CHANGE_PASSWORD: '/account/password/change',
  // Auth: Sessions
  SESSIONS: '/auth/sessions',
  EMAIL: '/account/email',
  PROVIDERS: '/account/providers',

  // Invitations
  // Email signup requests
  EMAIL_REQUEST: '/invitations/email-requests/',
  EMAIL_REQUESTS_ADMIN: '/invitations/email-requests/admin/',
  EMAIL_REQUEST_UPDATE: (id: number) => `/invitations/email-requests/admin/${id}/`,
  EMAIL_REQUEST_DELETE: (id: number) => `/invitations/email-requests/admin/${id}/delete/`,

  // Invitations
  LIST_INVITATIONS: '/invitations/',
  CREATE_INVITATION: '/invitations/create/',
  RETRIEVE_INVITATION: (id: number) => `/invitations/${id}/`,
  UPDATE_INVITATION: (id: number) => `/invitations/${id}/update/`,
  DELETE_INVITATION: (id: number) => `/invitations/${id}/delete/`,
  RESEND_INVITATION: (id: number) => `/invitations/${id}/resend/`,
  VALIDATE_TOKEN: '/invitations/validate-token/',
  USE_INVITATION: (id: number) => `/invitations/${id}/use/`,

  // Invitation reminders
  LIST_REMINDERS: '/invitations/reminders/',
  SUBMIT_REMINDER: '/invitations/reminders/submit/',

  // Invitation SIGNUP
  SIGNUP_INVITATION: '/invitations/signup',
} as const)

export const Flows = Object.freeze({
  LOGIN: 'login',
  LOGIN_BY_CODE: 'login_by_code',
  MFA_AUTHENTICATE: 'mfa_authenticate',
  MFA_REAUTHENTICATE: 'mfa_reauthenticate',
  MFA_TRUST: 'mfa_trust',
  MFA_WEBAUTHN_SIGNUP: 'mfa_signup_webauthn',
  PASSWORD_RESET_BY_CODE: 'password_reset_by_code',
  PROVIDER_REDIRECT: 'provider_redirect',
  PROVIDER_SIGNUP: 'provider_signup',
  REAUTHENTICATE: 'reauthenticate',
  SIGNUP: 'signup',
  VERIFY_EMAIL: 'verify_email',
})

export const AuthenticatorType = Object.freeze({
  TOTP: 'totp',
  RECOVERY_CODES: 'recovery_codes',
  WEBAUTHN: 'webauthn'
})

export interface ConfigResponse {
  status: number
  data: {
    account?: {
      authentication_method?: string
      is_open_for_signup?: boolean
      email_verification?: string
      email_verification_by_code_enabled?: boolean
      [key: string]: unknown
    }
    socialaccount?: {
      providers?: {
        id: string
        name?: string
        [key: string]: unknown
      }[]
    }
    [key: string]: unknown
  }
}


export interface AuthResponse {
  status: number
  meta?: {
    is_authenticated?: boolean
    session_token?: string
    access_token?: string
    [key: string]: unknown
  }
  user?: Record<string, unknown>
  detail?: string
  errors?: Record<string, string[]>
  data?: {
    user?: Record<string, unknown>
    flows?: Flow[]
    methods?: Method[]
    [key: string]: unknown
  }
  [key: string]: unknown
}

interface Flow {
  id: string
  providers?: string[]
  [key: string]: unknown
}

interface Method {
  method: string
  at: number
  reauthenticated?: boolean
  [key: string]: unknown
}

export async function getAuthSSR(sessionid: string): Promise<AuthResponse> {
  const base = process.env.BACKEND_BASE_URL || 'https://backend.oem-x.my.id'
  const resp = await fetch(`${base}/_allauth/browser/v1/auth/session`, {
    headers: { Cookie: `sessionid=${sessionid}` },
    cache: 'no-store',
  })
  return await resp.json()
}

export async function getConfigSSR() {
  const base = process.env.BACKEND_BASE_URL || 'https://backend.oem-x.my.id'
  const res = await fetch(`${base}/_allauth/browser/v1/config`, {
    headers: {
      Accept: 'application/json',
    },
    cache: 'no-store',
  })
  return res.json()
}

function buildHeaders(path: string, extraHeaders: Record<string, string> = {}): Record<string, string> {
  const headers: Record<string, string> = {
    ...ACCEPT_JSON,
    ...extraHeaders
  }

  if (path !== URLs.CSRF && path !== URLs.CONFIG && typeof window !== 'undefined') {
    const csrf = getCSRFToken()
    if (csrf) headers['X-CSRFToken'] = csrf
  }

  return headers
}

export async function fetchCSRFToken(): Promise<void> {
  await fetch(`${settings.baseUrl}${URLs.CSRF}`, {
    method: 'GET',
    credentials: 'include',
    mode: 'cors',
  })
}

export async function request<T = AuthResponse>(
  method: string,
  path: string,
  data?: unknown,
  extraHeaders: Record<string, string> = {}
): Promise<T> {
  const headers: Record<string, string> = buildHeaders(path, extraHeaders)

  // CSRF injection (seperti sebelumnya)
  if (typeof window !== "undefined" && method !== "GET") {
    let csrf = getCSRFToken()
    if (!csrf) {
      console.info("[request] csrftoken belum ada, fetching...")
      try {
        await fetchCSRFToken()
        csrf = getCSRFToken()
        if (!csrf) throw new Error("csrf fetch succeeded but token still missing")
      } catch (err) {
        console.error("[request] Gagal fetch CSRF token:", err)
        throw new Error("Tidak bisa mendapatkan CSRF token.")
      }
    }
    headers["X-CSRFToken"] = csrf
  }

  const options: RequestInit = {
    method,
    headers,
    credentials: "include",
  }

  if (data !== undefined) {
    if (typeof FormData !== "undefined" && data instanceof FormData) {
      // ✅ kalau FormData, langsung assign
      options.body = data
      // penting: jangan set Content-Type manual
    } else {
      options.body = JSON.stringify(data)
      headers["Content-Type"] = "application/json"
    }
  }

  try {
    const res = await fetch(settings.baseUrl + path, options)

    if (res.status === 204) {
      return {} as T
    }

    let json: any = null
    try {
      json = await res.json()
    } catch (e) {
      if (res.ok) {
        return {} as T
      }
      throw new Error("Server response not valid JSON.")
    }

    if (!res.ok) {
      const error = new Error(json?.detail || "Terjadi kesalahan.") as Error & {
        status?: number
        data?: unknown
      }
      error.status = res.status
      error.data = json
      throw error
    }

    return json as T
  } catch (err: unknown) {
    if (typeof err === "object" && err !== null && "status" in err) {
      throw err
    }
    throw new Error("Gagal terhubung ke server atau respons tidak valid.")
  }
}

export async function getConfig(): Promise<ConfigResponse> {
  return request('GET', URLs.CONFIG)
}

export interface ConfigType {
  account?: Record<string, unknown>
  socialaccount?: {
    providers?: { id: string; name?: string }[]
  }
  usersessions?: Record<string, unknown>
  [key: string]: unknown
}

export async function fetchConfig(): Promise<ConfigType | null> {
  const res = await getConfig()
  console.log('[fetchConfig] called at:', new Date().toISOString())
  console.log('[fetchConfig] raw result:', res)
  return res.data ?? null
}

export async function getAuth(): Promise<AuthResponse> {
  return request('GET', URLs.SESSION)
}

export async function login(data: Record<string, unknown>): Promise<AuthResponse> {
  return request('POST', URLs.LOGIN, data)
}

export async function logout(): Promise<AuthResponse> {
  return request('DELETE', URLs.LOGOUT)
}

export async function signUp(data: Record<string, unknown>): Promise<AuthResponse> {
  return request('POST', URLs.SIGNUP, data)
}

export async function changePassword(data: {
  current_password: string
  new_password: string
}): Promise<AuthResponse> {
  return request('POST', URLs.CHANGE_PASSWORD, data)
}

export async function reauthenticate(data: Record<string, unknown>): Promise<AuthResponse> {
  return request('POST', URLs.REAUTHENTICATE, data)
}

export async function requestPasswordReset(email: string): Promise<AuthResponse> {
  return request('POST', URLs.REQUEST_PASSWORD_RESET, { email })
}

export async function resetPassword(data: Record<string, unknown>): Promise<AuthResponse> {
  return request('POST', URLs.RESET_PASSWORD, data)
}

export async function verifyEmail(key: string): Promise<AuthResponse> {
  return request('POST', URLs.VERIFY_EMAIL, { key })
}

export async function getEmailVerification(key: string): Promise<AuthResponse> {
  return request('GET', `${URLs.VERIFY_EMAIL}?key=${encodeURIComponent(key)}`, undefined, // backticks
    { 'X-Email-Verification-Key': key }
  );
}

export function requestEmailVerificationUnauthenticated(params: { email: string }): Promise<AuthResponse> {
  return request(
    'POST',
    '/auth/email/verify/resend',
    { email: params.email }
  )
  // Response {"status": 409} because this endpoint flow with code ("allauth openapi documentation") not link, need adjust backend ("future")
}

export function sendEmailVerification(params: { email: string }): Promise<AuthResponse> {
  return request(
    'POST', // ⬅️ Ganti jadi PUT
    '/auth/resend-verification/',
    {
      email: params.email,
    }
  )
}

export function redirectToProvider(providerId: string, callbackURL: string, process: string = AuthProcess.LOGIN): void {
  if (typeof window === 'undefined') return

  const form = document.createElement('form')
  form.method = 'POST'
  form.action = `${settings.baseUrl}${URLs.REDIRECT_TO_PROVIDER}`

  const inputs = {
    provider: providerId,
    process,
    callback_url: window.location.origin + callbackURL,
    csrfmiddlewaretoken: getCSRFToken() || '',
  }

  for (const [name, value] of Object.entries(inputs)) {
    const input = document.createElement('input')
    input.type = 'hidden'
    input.name = name
    input.value = value
    form.appendChild(input)
  }

  document.body.appendChild(form)
  form.submit()
}

export type SessionInfo = {
  id: string
  created_at: number
  ip: string
  user_agent: string
  last_seen_at?: string
  is_current: boolean
}

export async function getSessions(): Promise<{ status: number; data: SessionInfo[] }> {
  return await request('GET', URLs.SESSIONS)
}

export type SessionType = {
  id: string
  created_at: number
  ip: string
  user_agent: string
  last_seen_at?: string
  is_current: boolean
}

export async function endSessions(ids: string[]): Promise<AuthResponse> {
  return await request('DELETE', URLs.SESSIONS, { sessions: ids })
}

// Digunakan oleh endpoint /account/email
export interface EmailAddress {
  email: string
  verified: boolean
  primary: boolean
}

export async function getEmailAddresses(): Promise<{ status: number; data: EmailAddress[] }> {
  return await request('GET', URLs.EMAIL)
}

export async function addEmail(email: string): Promise<{ status: number; data: EmailAddress[] }> {
  return await request('POST', URLs.EMAIL, { email })
}

export async function requestEmailVerification(email: string): Promise<{ status: number }> {
  return await request('PUT', URLs.EMAIL, { email })
}

export async function deleteEmail(email: string): Promise<{ status: number; data: EmailAddress[] }> {
  return await request('DELETE', URLs.EMAIL, { email })
}

export async function markEmailAsPrimary(email: string): Promise<{ status: number; data: EmailAddress[] }> {
  return await request('PATCH', URLs.EMAIL, { email, primary: true })
}

// 🔹 Struktur data yang dikirim untuk signup provider
export interface ProviderSignupData {
  provider: string
  access_token?: string
  code?: string
  id_token?: string
  [key: string]: unknown
}

export interface ProviderAccount {
  uid: string
  display: string
  provider: {
    id: string
    name: string
  }
}

// ✅ Response khusus provider API (tidak extend AuthResponse)
export interface ProviderAccountResponse {
  status: number
  detail?: string
  errors?: Record<string, string[]>
  data?: ProviderAccount[]
}

// Fungsi-fungsi API sosial
export async function providerSignup(
  data: ProviderSignupData
): Promise<ProviderAccountResponse> {
  return await request<ProviderAccountResponse>('POST', URLs.PROVIDER_SIGNUP, data)
}

export async function getProviderAccounts(): Promise<ProviderAccountResponse> {
  return await request<ProviderAccountResponse>('GET', URLs.PROVIDERS)
}

export async function disconnectProviderAccount(
  providerId: string,
  accountUid: string
): Promise<ProviderAccountResponse> {
  return await request<ProviderAccountResponse>('DELETE', URLs.PROVIDERS, {
    provider: providerId,
    account: accountUid,
  })
}

// Untuk invitation only
// Email signup request
export function submitEmailRequest(email: string) {
  return request('POST', URLs.EMAIL_REQUEST, { email });
}

export async function listEmailRequests() {
  const res = await request('GET', URLs.EMAIL_REQUESTS_ADMIN);
  return res.results || res;
}
export function updateEmailRequest(id: number, data: any) {
  return request('PATCH', URLs.EMAIL_REQUEST_UPDATE(id), data);
}
export function deleteEmailRequest(id: number) {
  return request('DELETE', URLs.EMAIL_REQUEST_DELETE(id));
}

// Invitations CRUD
export function listInvitations() {
  return request('GET', URLs.LIST_INVITATIONS);
}

export function createInvitation(data: { email: string; invited_by?: string, expires_at: string }) {
  return request('POST', URLs.CREATE_INVITATION, data);
}
export function retrieveInvitation(id: number) {
  return request('GET', URLs.RETRIEVE_INVITATION(id));
}
export function updateInvitation(id: number, data: any) {
  return request('PATCH', URLs.UPDATE_INVITATION(id), data);
}
export function deleteInvitation(id: number) {
  return request('DELETE', URLs.DELETE_INVITATION(id));
}
export function resendInvitation(id: number) {
  return request('POST', URLs.RESEND_INVITATION(id));
}

export function validateToken(token: string) {
  return request('POST', URLs.VALIDATE_TOKEN, { token });
}
export function useInvitation(id: number) {
  return request('POST', URLs.USE_INVITATION(id));
}

// Reminders
export function listReminders() {
  return request('GET', URLs.LIST_REMINDERS);
}
export function submitReminder(email: string) {
  return request('POST', URLs.SUBMIT_REMINDER, { email });
}

// Register With Invitation
export function registerWithInvitation(data: {
  email: string;
  password1: string;
  password2: string;
  token: string;
}) {
  // endpoint django-allauth headless ketika SIGNUP_DISABLED=False,
  // atau custom CustomRegisterView ketika SIGNUP_DISABLED=True
  return request('POST', URLs.SIGNUP_INVITATION, data);
}


----------------------------------------

