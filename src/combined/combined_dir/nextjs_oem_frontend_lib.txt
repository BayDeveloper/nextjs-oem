
-- /nextjs_oem_frontend/lib/django.ts --
// lib/django.ts
export function getCSRFToken(): string | null {
  if (typeof document === 'undefined') return null

  const getCookie = (name: string): string | null => {
    const cookies = document.cookie.split(';')
    for (const cookie of cookies) {
      const trimmed = cookie.trim()
      if (trimmed.startsWith(`${name}=`)) {
        return decodeURIComponent(trimmed.substring(name.length + 1))
      }
    }
    return null
  }

  return getCookie('csrftoken')
}



----------------------------------------


-- /nextjs_oem_frontend/lib/allauth.ts --
// lib/allauth.ts
import { getCSRFToken } from './django'

export const Client = Object.freeze({
  BROWSER: 'browser' as const
})

export const settings = {
  client: Client.BROWSER,
  baseUrl: `https://backend.oem-x.my.id/_allauth/${Client.BROWSER}/v1`,
  withCredentials: true
}

const ACCEPT_JSON = {
  accept: 'application/json'
}

export const AuthProcess = Object.freeze({
  LOGIN: 'login',
  CONNECT: 'connect',
})

export const URLs = Object.freeze({
  CSRF: '/auth/csrf',
  CONFIG: '/config',
  SESSION: '/auth/session',
  LOGIN: '/auth/login',
  LOGOUT: '/auth/session',
  SIGNUP: '/auth/signup',
  REAUTHENTICATE: '/auth/reauthenticate',
  VERIFY_EMAIL: '/auth/email/verify',
  REQUEST_PASSWORD_RESET: '/auth/password/request',
  RESET_PASSWORD: '/auth/password/reset',
  PROVIDER_SIGNUP: '/auth/provider/signup',
  REDIRECT_TO_PROVIDER: '/auth/provider/redirect',
  PROVIDER_TOKEN: '/auth/provider/token',
  CHANGE_PASSWORD: '/account/password/change',
  // Auth: Sessions
  SESSIONS: '/auth/sessions',
  EMAIL: '/account/email',
  PROVIDERS: '/account/providers',

  // Invitations
  // Email signup requests
  EMAIL_REQUEST: '/invitations/email-requests/',
  EMAIL_REQUESTS_ADMIN: '/invitations/email-requests/admin/',
  EMAIL_REQUEST_UPDATE: (id: number) => `/invitations/email-requests/admin/${id}/`,
  EMAIL_REQUEST_DELETE: (id: number) => `/invitations/email-requests/admin/${id}/delete/`,

  // Invitations
  LIST_INVITATIONS: '/invitations/',
  CREATE_INVITATION: '/invitations/create/',
  RETRIEVE_INVITATION: (id: number) => `/invitations/${id}/`,
  UPDATE_INVITATION: (id: number) => `/invitations/${id}/update/`,
  DELETE_INVITATION: (id: number) => `/invitations/${id}/delete/`,
  RESEND_INVITATION: (id: number) => `/invitations/${id}/resend/`,
  VALIDATE_TOKEN: '/invitations/validate-token/',
  USE_INVITATION: (id: number) => `/invitations/${id}/use/`,

  // Invitation reminders
  LIST_REMINDERS: '/invitations/reminders/',
  SUBMIT_REMINDER: '/invitations/reminders/submit/',

  // Invitation SIGNUP
  SIGNUP_INVITATION: '/invitations/signup',
} as const)

export const Flows = Object.freeze({
  LOGIN: 'login',
  LOGIN_BY_CODE: 'login_by_code',
  MFA_AUTHENTICATE: 'mfa_authenticate',
  MFA_REAUTHENTICATE: 'mfa_reauthenticate',
  MFA_TRUST: 'mfa_trust',
  MFA_WEBAUTHN_SIGNUP: 'mfa_signup_webauthn',
  PASSWORD_RESET_BY_CODE: 'password_reset_by_code',
  PROVIDER_REDIRECT: 'provider_redirect',
  PROVIDER_SIGNUP: 'provider_signup',
  REAUTHENTICATE: 'reauthenticate',
  SIGNUP: 'signup',
  VERIFY_EMAIL: 'verify_email',
})

export const AuthenticatorType = Object.freeze({
  TOTP: 'totp',
  RECOVERY_CODES: 'recovery_codes',
  WEBAUTHN: 'webauthn'
})

export interface ConfigResponse {
  status: number
  data: {
    account?: {
      authentication_method?: string
      is_open_for_signup?: boolean
      email_verification?: string
      email_verification_by_code_enabled?: boolean
      [key: string]: unknown
    }
    socialaccount?: {
      providers?: {
        id: string
        name?: string
        [key: string]: unknown
      }[]
    }
    [key: string]: unknown
  }
}


export interface AuthResponse {
  status: number
  meta?: {
    is_authenticated?: boolean
    session_token?: string
    access_token?: string
    [key: string]: unknown
  }
  user?: Record<string, unknown>
  detail?: string
  errors?: Record<string, string[]>
  data?: {
    user?: Record<string, unknown>
    flows?: Flow[]
    methods?: Method[]
    [key: string]: unknown
  }
  [key: string]: unknown
}

interface Flow {
  id: string
  providers?: string[]
  [key: string]: unknown
}

interface Method {
  method: string
  at: number
  reauthenticated?: boolean
  [key: string]: unknown
}

export async function getAuthSSR(sessionid: string): Promise<AuthResponse> {
  const base = process.env.BACKEND_BASE_URL || 'https://backend.oem-x.my.id'
  const resp = await fetch(`${base}/_allauth/browser/v1/auth/session`, {
    headers: { Cookie: `sessionid=${sessionid}` },
    cache: 'no-store',
  })
  return await resp.json()
}

export async function getConfigSSR() {
  const base = process.env.BACKEND_BASE_URL || 'https://backend.oem-x.my.id'
  const res = await fetch(`${base}/_allauth/browser/v1/config`, {
    headers: {
      Accept: 'application/json',
    },
    cache: 'no-store',
  })
  return res.json()
}

function buildHeaders(path: string, extraHeaders: Record<string, string> = {}): Record<string, string> {
  const headers: Record<string, string> = {
    ...ACCEPT_JSON,
    ...extraHeaders
  }

  if (path !== URLs.CSRF && path !== URLs.CONFIG && typeof window !== 'undefined') {
    const csrf = getCSRFToken()
    if (csrf) headers['X-CSRFToken'] = csrf
  }

  return headers
}

export async function fetchCSRFToken(): Promise<void> {
  await fetch(`${settings.baseUrl}${URLs.CSRF}`, {
    method: 'GET',
    credentials: 'include',
    mode: 'cors',
  })
}

export async function request<T = AuthResponse>(
  method: string,
  path: string,
  data?: unknown,
  extraHeaders: Record<string, string> = {}
): Promise<T> {
  const headers: Record<string, string> = buildHeaders(path, extraHeaders)

  // CSRF injection (seperti sebelumnya)
  if (typeof window !== "undefined" && method !== "GET") {
    let csrf = getCSRFToken()
    if (!csrf) {
      console.info("[request] csrftoken belum ada, fetching...")
      try {
        await fetchCSRFToken()
        csrf = getCSRFToken()
        if (!csrf) throw new Error("csrf fetch succeeded but token still missing")
      } catch (err) {
        console.error("[request] Gagal fetch CSRF token:", err)
        throw new Error("Tidak bisa mendapatkan CSRF token.")
      }
    }
    headers["X-CSRFToken"] = csrf
  }

  const options: RequestInit = {
    method,
    headers,
    credentials: "include",
  }

  if (data !== undefined) {
    if (typeof FormData !== "undefined" && data instanceof FormData) {
      // ✅ kalau FormData, langsung assign
      options.body = data
      // penting: jangan set Content-Type manual
    } else {
      options.body = JSON.stringify(data)
      headers["Content-Type"] = "application/json"
    }
  }

  try {
    const res = await fetch(settings.baseUrl + path, options)

    if (res.status === 204) {
      return {} as T
    }

    let json: any = null
    try {
      json = await res.json()
    } catch (e) {
      if (res.ok) {
        return {} as T
      }
      throw new Error("Server response not valid JSON.")
    }

    if (!res.ok) {
      const error = new Error(json?.detail || "Terjadi kesalahan.") as Error & {
        status?: number
        data?: unknown
      }
      error.status = res.status
      error.data = json
      throw error
    }

    return json as T
  } catch (err: unknown) {
    if (typeof err === "object" && err !== null && "status" in err) {
      throw err
    }
    throw new Error("Gagal terhubung ke server atau respons tidak valid.")
  }
}

export async function getConfig(): Promise<ConfigResponse> {
  return request('GET', URLs.CONFIG)
}

export interface ConfigType {
  account?: Record<string, unknown>
  socialaccount?: {
    providers?: { id: string; name?: string }[]
  }
  usersessions?: Record<string, unknown>
  [key: string]: unknown
}

export async function fetchConfig(): Promise<ConfigType | null> {
  const res = await getConfig()
  console.log('[fetchConfig] called at:', new Date().toISOString())
  console.log('[fetchConfig] raw result:', res)
  return res.data ?? null
}

export async function getAuth(): Promise<AuthResponse> {
  return request('GET', URLs.SESSION)
}

export async function login(data: Record<string, unknown>): Promise<AuthResponse> {
  return request('POST', URLs.LOGIN, data)
}

export async function logout(): Promise<AuthResponse> {
  return request('DELETE', URLs.LOGOUT)
}

export async function signUp(data: Record<string, unknown>): Promise<AuthResponse> {
  return request('POST', URLs.SIGNUP, data)
}

export async function changePassword(data: {
  current_password: string
  new_password: string
}): Promise<AuthResponse> {
  return request('POST', URLs.CHANGE_PASSWORD, data)
}

export async function reauthenticate(data: Record<string, unknown>): Promise<AuthResponse> {
  return request('POST', URLs.REAUTHENTICATE, data)
}

export async function requestPasswordReset(email: string): Promise<AuthResponse> {
  return request('POST', URLs.REQUEST_PASSWORD_RESET, { email })
}

export async function resetPassword(data: Record<string, unknown>): Promise<AuthResponse> {
  return request('POST', URLs.RESET_PASSWORD, data)
}

export async function verifyEmail(key: string): Promise<AuthResponse> {
  return request('POST', URLs.VERIFY_EMAIL, { key })
}

export async function getEmailVerification(key: string): Promise<AuthResponse> {
  return request('GET', `${URLs.VERIFY_EMAIL}?key=${encodeURIComponent(key)}`, undefined, // backticks
    { 'X-Email-Verification-Key': key }
  );
}

export function requestEmailVerificationUnauthenticated(params: { email: string }): Promise<AuthResponse> {
  return request(
    'POST',
    '/auth/email/verify/resend',
    { email: params.email }
  )
  // Response {"status": 409} because this endpoint flow with code ("allauth openapi documentation") not link, need adjust backend ("future")
}

export function sendEmailVerification(params: { email: string }): Promise<AuthResponse> {
  return request(
    'POST', // ⬅️ Ganti jadi PUT
    '/auth/resend-verification/',
    {
      email: params.email,
    }
  )
}

export function redirectToProvider(providerId: string, callbackURL: string, process: string = AuthProcess.LOGIN): void {
  if (typeof window === 'undefined') return

  const form = document.createElement('form')
  form.method = 'POST'
  form.action = `${settings.baseUrl}${URLs.REDIRECT_TO_PROVIDER}`

  const inputs = {
    provider: providerId,
    process,
    callback_url: window.location.origin + callbackURL,
    csrfmiddlewaretoken: getCSRFToken() || '',
  }

  for (const [name, value] of Object.entries(inputs)) {
    const input = document.createElement('input')
    input.type = 'hidden'
    input.name = name
    input.value = value
    form.appendChild(input)
  }

  document.body.appendChild(form)
  form.submit()
}

export type SessionInfo = {
  id: string
  created_at: number
  ip: string
  user_agent: string
  last_seen_at?: string
  is_current: boolean
}

export async function getSessions(): Promise<{ status: number; data: SessionInfo[] }> {
  return await request('GET', URLs.SESSIONS)
}

export type SessionType = {
  id: string
  created_at: number
  ip: string
  user_agent: string
  last_seen_at?: string
  is_current: boolean
}

export async function endSessions(ids: string[]): Promise<AuthResponse> {
  return await request('DELETE', URLs.SESSIONS, { sessions: ids })
}

// Digunakan oleh endpoint /account/email
export interface EmailAddress {
  email: string
  verified: boolean
  primary: boolean
}

export async function getEmailAddresses(): Promise<{ status: number; data: EmailAddress[] }> {
  return await request('GET', URLs.EMAIL)
}

export async function addEmail(email: string): Promise<{ status: number; data: EmailAddress[] }> {
  return await request('POST', URLs.EMAIL, { email })
}

export async function requestEmailVerification(email: string): Promise<{ status: number }> {
  return await request('PUT', URLs.EMAIL, { email })
}

export async function deleteEmail(email: string): Promise<{ status: number; data: EmailAddress[] }> {
  return await request('DELETE', URLs.EMAIL, { email })
}

export async function markEmailAsPrimary(email: string): Promise<{ status: number; data: EmailAddress[] }> {
  return await request('PATCH', URLs.EMAIL, { email, primary: true })
}

// 🔹 Struktur data yang dikirim untuk signup provider
export interface ProviderSignupData {
  provider: string
  access_token?: string
  code?: string
  id_token?: string
  [key: string]: unknown
}

export interface ProviderAccount {
  uid: string
  display: string
  provider: {
    id: string
    name: string
  }
}

// ✅ Response khusus provider API (tidak extend AuthResponse)
export interface ProviderAccountResponse {
  status: number
  detail?: string
  errors?: Record<string, string[]>
  data?: ProviderAccount[]
}

// Fungsi-fungsi API sosial
export async function providerSignup(
  data: ProviderSignupData
): Promise<ProviderAccountResponse> {
  return await request<ProviderAccountResponse>('POST', URLs.PROVIDER_SIGNUP, data)
}

export async function getProviderAccounts(): Promise<ProviderAccountResponse> {
  return await request<ProviderAccountResponse>('GET', URLs.PROVIDERS)
}

export async function disconnectProviderAccount(
  providerId: string,
  accountUid: string
): Promise<ProviderAccountResponse> {
  return await request<ProviderAccountResponse>('DELETE', URLs.PROVIDERS, {
    provider: providerId,
    account: accountUid,
  })
}

// Untuk invitation only
// Email signup request
export function submitEmailRequest(email: string) {
  return request('POST', URLs.EMAIL_REQUEST, { email });
}

export async function listEmailRequests() {
  const res = await request('GET', URLs.EMAIL_REQUESTS_ADMIN);
  return res.results || res;
}
export function updateEmailRequest(id: number, data: any) {
  return request('PATCH', URLs.EMAIL_REQUEST_UPDATE(id), data);
}
export function deleteEmailRequest(id: number) {
  return request('DELETE', URLs.EMAIL_REQUEST_DELETE(id));
}

// Invitations CRUD
export function listInvitations() {
  return request('GET', URLs.LIST_INVITATIONS);
}

export function createInvitation(data: { email: string; invited_by?: string, expires_at: string }) {
  return request('POST', URLs.CREATE_INVITATION, data);
}
export function retrieveInvitation(id: number) {
  return request('GET', URLs.RETRIEVE_INVITATION(id));
}
export function updateInvitation(id: number, data: any) {
  return request('PATCH', URLs.UPDATE_INVITATION(id), data);
}
export function deleteInvitation(id: number) {
  return request('DELETE', URLs.DELETE_INVITATION(id));
}
export function resendInvitation(id: number) {
  return request('POST', URLs.RESEND_INVITATION(id));
}

export function validateToken(token: string) {
  return request('POST', URLs.VALIDATE_TOKEN, { token });
}
export function useInvitation(id: number) {
  return request('POST', URLs.USE_INVITATION(id));
}

// Reminders
export function listReminders() {
  return request('GET', URLs.LIST_REMINDERS);
}
export function submitReminder(email: string) {
  return request('POST', URLs.SUBMIT_REMINDER, { email });
}

// Register With Invitation
export function registerWithInvitation(data: {
  email: string;
  password1: string;
  password2: string;
  token: string;
}) {
  // endpoint django-allauth headless ketika SIGNUP_DISABLED=False,
  // atau custom CustomRegisterView ketika SIGNUP_DISABLED=True
  return request('POST', URLs.SIGNUP_INVITATION, data);
}


----------------------------------------


-- /nextjs_oem_frontend/lib/hooks/useSessions.ts --
// lib/hooks/useSessions.ts
import useSWR from 'swr'
import { getSessions } from '../allauth'

export function useSessions() {
  return useSWR('/auth/sessions', async () => await getSessions(), {
    revalidateOnFocus: true
  })
}


----------------------------------------


-- /nextjs_oem_frontend/lib/hooks/useAuthConfig.ts --
// lib/hooks/useAuthConfig.ts
import useSWR from 'swr'
import { getConfig, ConfigResponse } from '../allauth'

export function useAuthConfig() {
  return useSWR<ConfigResponse>('/auth/config', getConfig, {
    revalidateOnFocus: false,
    dedupingInterval: 5 * 60 * 1000,
  })
}


----------------------------------------


-- /nextjs_oem_frontend/lib/hooks/useInvitation.ts --
// src/lib/hooks/useInvitation.ts
import { useState, useCallback } from 'react';
import * as API from '../../lib/allauth';

export interface InvitationValidationResponse {
  id: number;
  email: string;
  token: string;
  expires_at: string;
  used: boolean;
  [key: string]: any;
}

export function useInvitation() {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const sendEmailRequest = useCallback(async (email: string) => {
    setLoading(true);
    setError(null);
    try {
      return await API.submitEmailRequest(email);
    } catch (e: any) {
      setError(e.data?.detail || e.message);
      return undefined;
    } finally {
      setLoading(false);
    }
  }, []);

  const validateToken = useCallback(async (token: string): Promise<InvitationValidationResponse | undefined> => {
    setLoading(true);
    setError(null);
    try {
      return await API.validateToken(token);
    } catch (e: any) {
      setError(e.data?.detail || e.message);
      return undefined;
    } finally {
      setLoading(false);
    }
  }, []);

  // 2) Signup dengan invitation
  const signupWithToken = useCallback(async ({
    email, password1, password2, token
  }: {
    email: string;
    password1: string;
    password2: string;
    token: string;
  }) => {
    setLoading(true); setError(null);
    try {
      // a) Panggil endpoint headless signup
      const signupResp = await API.registerWithInvitation({ email, password1, password2, token });
      // b) Jika signup berhasil, tandai token sebagai used
      if (signupResp && signupResp.detail) {
        await API.useInvitation(signupResp.id);   // atau panggil useInvitation(validateResp.id)
      }
      return signupResp;
    } catch (e: any) {
      setError(e.data?.detail || e.message);
      return undefined;
    } finally {
      setLoading(false);
    }
  }, []);

  return {
    loading,
    error,
    sendEmailRequest,
    validateToken,
    signupWithToken,
  };
}


----------------------------------------


-- /nextjs_oem_frontend/lib/hooks/useProviderAccounts.ts --
// lib/hooks/useProviderAccounts.ts
import useSWR from 'swr'
import { getProviderAccounts } from '../allauth'

export function useProviderAccounts() {
  return useSWR('/account/provider', getProviderAccounts)
}


----------------------------------------


-- /nextjs_oem_frontend/lib/hooks/useEmailAddresses.ts --
// lib/hooks/useEmailAddresses.ts
import useSWR from 'swr'
import { getEmailAddresses } from '../allauth'

export function useEmailAddresses() {
  return useSWR('/auth/email', getEmailAddresses)
}


----------------------------------------


-- /nextjs_oem_frontend/lib/helpers/ClientOnly.tsx --
// lib/helpers/ClientOnly.tsx
'use client'

import React, { useEffect, useState } from 'react'

export function ClientOnly({ children }: { children: React.ReactNode }) {
  const [hasMounted, setHasMounted] = useState(false)

  useEffect(() => {
    setHasMounted(true)
  }, [])

  if (!hasMounted) return null
  return <>{children}</>
}


----------------------------------------


-- /nextjs_oem_frontend/lib/helpers/withSafeRender.tsx --
// === src/lib/helpers/withSafeRender.tsx ===
'use client'

import React, { JSX } from 'react'

/**
 * HOC untuk menunda render komponen sampai kondisi isReady() terpenuhi.
 * @param Component Komponen React yang ingin dibungkus.
 * @param isReady   Fungsi yang mengembalikan boolean; render hanya ketika true.
 * @param Fallback  Konten yang dirender sementara isReady() masih false.
 */
export function withSafeRender<T extends JSX.IntrinsicAttributes>(
  Component: React.ComponentType<T>,
  isReady: () => boolean,
  Fallback: React.ReactNode = <p>Memuat...</p>
) {
  return function WrappedComponent(props: T) {
    // Jika belum siap, tampilkan fallback
    if (!isReady()) {
      return <>{Fallback} </>
    }
    // Setelah siap, render komponen utama
    return <Component {...props} />
  }
}


----------------------------------------


-- /nextjs_oem_frontend/lib/helpers/useRequest.ts --
// lib/helpers/useRequest.ts
import { useState, useCallback } from 'react';

type RequestFn<T, A extends unknown[]> = (...args: A) => Promise<T>;

// K: tipe ID bisa number atau string tergantung kebutuhan
export function useRequest<
  T,
  A extends unknown[] = unknown[],
  K extends number | string = number
>(
  fn: RequestFn<T, A>,
  options?: { idIndex?: number } // index argumen yang mengandung ID
) {
  const [error, setError] = useState<string | null>(null);
  const [loadingId, setLoadingId] = useState<K | null>(null);

  const trigger = useCallback(
    async (...args: A): Promise<T | null> => {
      setError(null);

      // Tangkap ID dari argumen kalau ada
      if (typeof options?.idIndex === 'number') {
        const maybeId = args[options.idIndex] as K;
        if (maybeId !== undefined) {
          setLoadingId(maybeId);
        }
      } else {
        // fallback: pakai 'GLOBAL' sebagai indikator loading umum
        setLoadingId('GLOBAL' as K);
      }

      try {
        const resp = await fn(...args);
        return resp;
      } catch (err) {
        const e = err as { message?: string; data?: { detail?: string } };
        const msg =
          e?.data?.detail ||
          e?.message ||
          'Terjadi kesalahan. Coba lagi nanti.';
        setError(msg);
        return null;
      } finally {
        setLoadingId(null);
      }
    },
    [fn, options?.idIndex]
  );

  return { trigger, error, loadingId };
}


----------------------------------------

