
-- /nextjs_oem_frontend/auth/useLogout.ts --
'use client'

import { useCallback, useState, useEffect } from 'react'
import { fetchCSRFToken, logout } from '../lib/allauth'
import { useAuth } from './AuthContext'
import { useRouter } from 'next/navigation'
import { mutate } from 'swr'

type LogoutError = {
  status?: number
  [key: string]: unknown
}

export function useLogout(redirectTo: string = '/account/login') {
  const [logoutRequested, setLogoutRequested] = useState(false)
  const { isAuthenticated, loading } = useAuth()
  const router = useRouter()

  const triggerLogout = useCallback(async () => {
    try {
      await fetchCSRFToken()
      await logout()
    } catch (err: unknown) {
      const error = err as LogoutError
      if (error.status !== 401) {
        console.error('Logout error:', error)
      }
    } finally {
      await mutate('/auth/session', null, false)
      setLogoutRequested(true)
    }
  }, [])

  useEffect(() => {
    if (!loading && !isAuthenticated && logoutRequested) {
      router.replace(redirectTo)
    }
  }, [loading, isAuthenticated, logoutRequested, router, redirectTo])

  return { triggerLogout, logoutRequested }
}


----------------------------------------


-- /nextjs_oem_frontend/auth/useCSRF.ts --
// src/auth/useCSRF.ts
"use client";

import useSWR from "swr";

// Gunakan fetcher default dari SWRConfig
export function useCSRF() {
  return useSWR(
    "/_allauth/browser/v1/auth/csrf",
    (url: string) => fetch(url, { credentials: "include" }),  // hanya perlu fetch saja
    {
      revalidateOnFocus: false,
      dedupingInterval: 5 * 60 * 1000,  // satu kali fetch tiap 5 menit
    }
  );
}


----------------------------------------


-- /nextjs_oem_frontend/auth/routing.ts --
// auth/routing.ts
import { AuthenticatorType, AuthResponse, Flows } from "../lib/allauth";

const flow2path: Record<string, string> = {
  [Flows.LOGIN]: '/account/login',
  [Flows.LOGIN_BY_CODE]: '/account/login/code/confirm',
  [Flows.SIGNUP]: '/account/signup',
  [Flows.VERIFY_EMAIL]: '/account/verify-email',
  [Flows.PASSWORD_RESET_BY_CODE]: '/account/password/reset/confirm',
  [Flows.PROVIDER_SIGNUP]: '/account/provider/signup',
  [Flows.REAUTHENTICATE]: '/account/reauthenticate',
  [Flows.MFA_TRUST]: '/account/2fa/trust',
  [`${Flows.MFA_AUTHENTICATE}:${AuthenticatorType.TOTP}`]: '/account/authenticate/totp',
  [`${Flows.MFA_AUTHENTICATE}:${AuthenticatorType.RECOVERY_CODES}`]: '/account/authenticate/recovery-codes',
  [`${Flows.MFA_AUTHENTICATE}:${AuthenticatorType.WEBAUTHN}`]: '/account/authenticate/webauthn',
  [`${Flows.MFA_REAUTHENTICATE}:${AuthenticatorType.TOTP}`]: '/account/reauthenticate/totp',
  [`${Flows.MFA_REAUTHENTICATE}:${AuthenticatorType.RECOVERY_CODES}`]: '/account/reauthenticate/recovery-codes',
  [`${Flows.MFA_REAUTHENTICATE}:${AuthenticatorType.WEBAUTHN}`]: '/account/reauthenticate/webauthn',
  [Flows.MFA_WEBAUTHN_SIGNUP]: '/account/signup/passkey/create',
}

type FlowType = {
  id: string
  types?: string[]
  is_pending?: boolean
}

export function pathForFlow(flow: FlowType, typ?: string): string {
  let key = flow.id
  if (typeof flow.types !== 'undefined') {
    typ = typ ?? flow.types[0]
    key = `${key}:${typ}`
  }
  const path = flow2path[key] ?? flow2path[flow.id]
  if (!path) {
    throw new Error(`Unknown path for flow: ${flow.id}`)
  }
  return path
}

export function pathForPendingFlow(auth?: AuthResponse | null): string | null {
  const flow = auth?.data?.flows?.find((f): f is FlowType => !!f?.is_pending)
  return flow ? pathForFlow(flow, undefined) : null
}


----------------------------------------


-- /nextjs_oem_frontend/auth/csrfMiddleware.ts --
// src/auth/csrfMiddleware.ts
import { Middleware } from "swr";
import { getCSRFToken } from "../lib/django";

// Middleware SWR untuk inject CSRF secara transparan
export const csrfMiddleware: Middleware = (useSWRNext) => {
  return (key, fetcher, config) => {
    if (!fetcher) {
      throw new Error("csrfMiddleware requires a fetcher");
    }

    const fetcherWithCSRF: typeof fetcher = async (url, init?) => {
      // Hanya fetch CSRF jika token belum ada
      let token = getCSRFToken();
      if (!token) {
        await fetch("https://backend.oem-x.my.id/_allauth/browser/v1/auth/csrf", {
          credentials: "include",
        });
        token = getCSRFToken(); // ambil ulang
      }

      const headers = {
        ...(init?.headers ?? {}),
        "X-CSRFToken": token ?? "",
      };

      return fetcher(url, {
        ...init,
        headers,
        credentials: "include",
      } as any);
    };

    return useSWRNext(key, fetcherWithCSRF, config);
  };
};


----------------------------------------


-- /nextjs_oem_frontend/auth/AuthContext.tsx --
"use client"

import React, {
  createContext,
  useContext,
  ReactNode,
  JSX,
  useEffect,
} from 'react'
import useSWR from 'swr'
import { useRouter, useSearchParams, usePathname } from 'next/navigation'
import { ConfigType, fetchCSRFToken, fetchConfig, getAuth } from '../lib/allauth'
import { useRecentlyReauthenticated } from '../utils/reauth'

interface Flow {
  id: string
  is_pending?: boolean
  types?: string[]
  providers?: string[]
  [key: string]: unknown
}

interface Method {
  method: string
  at: number
  reauthenticated?: boolean
  [key: string]: unknown
}

export interface AuthContextType {
  isAuthenticated: boolean
  user: Record<string, unknown> | null
  flows: Flow[]
  providers: string[]
  methods: Method[]
  tokens: {
    session_token?: string
    access_token?: string
  }
  loading: boolean
  lastReauthenticatedAt: string | null
}

const defaultAuth: AuthContextType = {
  isAuthenticated: false,
  user: null,
  flows: [],
  providers: [],
  methods: [],
  tokens: {},
  loading: true,
  lastReauthenticatedAt: null,
}

const AuthContext = createContext<AuthContextType>(defaultAuth)
const ConfigContext = createContext<ConfigType | null>(null)

interface AuthProviderProps {
  children: ReactNode
  initialAuth?: AuthContextType
  initialConfig?: ConfigType | null
}

const fetchAuth = async (): Promise<AuthContextType> => {
  await fetchCSRFToken()
  const resp = await getAuth()

  if (resp.status === 401 || !resp.meta?.is_authenticated) {
    console.warn('[fetchAuth] Tidak terautentikasi')
    return defaultAuth
  }

  const data = resp.data ?? {}
  const meta = resp.meta ?? {}

  console.log('[fetchAuth] response:', resp)

  const flows = (data.flows ?? []) as Flow[]
  const providers =
    flows.find((f) => f.id === 'provider_redirect')?.providers ?? []

  return {
    isAuthenticated: meta.is_authenticated ?? false,
    user: data.user ?? null,
    flows,
    providers,
    methods: (data.methods ?? []) as Method[],
    tokens: {
      session_token: meta.session_token,
      access_token: meta.access_token,
    },
    loading: false,
    lastReauthenticatedAt: typeof meta.last_reauthenticated_at === 'string'
      ? meta.last_reauthenticated_at
      : null,
  }
}

export function AuthProvider({
  children,
  initialAuth,
  initialConfig,
}: AuthProviderProps) {
  const {
    data: auth = initialAuth ?? defaultAuth,
    isLoading: authLoading,
  } = useSWR<AuthContextType>('/auth/session', fetchAuth, {
    fallbackData: initialAuth,
    revalidateOnFocus: false,
    revalidateOnReconnect: false,
    dedupingInterval: 60000,
    revalidateOnMount: false,
    revalidateIfStale: false,
  })

  const {
    data: config,
    isLoading: configLoading,
    error: configError,
  } = useSWR<ConfigType | null>('/auth/config', fetchConfig, {
    fallbackData: initialConfig ?? null,
    revalidateOnFocus: false,
    revalidateOnReconnect: false,
    revalidateIfStale: false,
    revalidateOnMount: false,
    dedupingInterval: 300000,
  })

  useEffect(() => {
    if (configError) {
      console.error('[AuthContext] Gagal memuat config:', configError)
      console.log('[AuthProvider] config result:', config)
    }
  }, [configError, config])

  if (authLoading || configLoading) {
    return <div className="text-center p-5">Memuat konfigurasi auth...</div>
  }

  const value: AuthContextType = {
    ...auth,
    loading: authLoading,
  }

  return (
    <AuthContext.Provider value={value}>
      <ConfigContext.Provider value={config ?? null}>
        {children}
      </ConfigContext.Provider>
    </AuthContext.Provider>
  )
}

export function useAuth(): AuthContextType {
  return useContext(AuthContext)
}

export function useConfig(): ConfigType | null {
  return useContext(ConfigContext)
}

export function useAuthenticatedRoute(redirectTo = '/account/login') {
  const { isAuthenticated, loading } = useAuth()
  useEffect(() => {
    if (!loading && !isAuthenticated) {
      const next = window.location.pathname + window.location.search
      window.location.href = `${redirectTo}?next=${encodeURIComponent(next)}`
    }
  }, [loading, isAuthenticated, redirectTo])
}

export function useAnonymousRoute(redirectTo = '/') {
  const { isAuthenticated, loading } = useAuth()
  const router = useRouter()
  const params = useSearchParams()

  useEffect(() => {
    if (!loading && isAuthenticated) {
      const next = params.get('next')
      router.replace(next ?? redirectTo)
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [loading, isAuthenticated, params, router])
}

interface WithAuthOptions {
  redirectTo?: string; // default: '/account/login'
  role?: string;       // opsional, untuk cek role
}

export function withAuth<T extends JSX.IntrinsicAttributes>(
  Component: React.ComponentType<T>,
  options?: WithAuthOptions,
  Fallback: React.ReactNode = <div>Memuat...</div>
) {
  const redirectTo = options?.redirectTo || '/account/login';

  return function Wrapped(props: T) {
    const { isAuthenticated, loading, user } = useAuth();
    const params = useSearchParams();
    const pathname = usePathname();

    useEffect(() => {
      if (!loading) {
        // Belum login
        if (!isAuthenticated) {
          const next = params.get('next') || pathname;
          window.location.href = `${redirectTo}?next=${encodeURIComponent(next)}`;
        }
        // Sudah login tapi role tidak sesuai
        else if (options?.role && user?.role !== options.role) {
          window.location.href = '/403'; // halaman forbidden
        }
      }
    }, [loading, isAuthenticated, user, params, pathname]);

    // Tampilkan fallback saat loading
    if (loading) return <>{Fallback}</>;

    // Kalau user belum login atau role tidak cocok, jangan render apa-apa
    if (!isAuthenticated || (options?.role && user?.role !== options.role)) {
      return null;
    }

    // Kalau lolos semua cek, render komponen
    return <Component {...props} />;
  };
}


export function withAnonymous<T extends JSX.IntrinsicAttributes>(
  Component: React.ComponentType<T>,
  redirectTo = '/account'
) {
  return function Wrapped(props: T) {
    const { isAuthenticated, loading } = useAuth()
    const params = useSearchParams()
    const router = useRouter()

    useEffect(() => {
      if (!loading && isAuthenticated) {
        const next = params.get('next')
        router.replace(next ?? redirectTo)
      }
    }, [loading, isAuthenticated, params, router])

    if (loading || isAuthenticated) return null
    return <Component {...props} />
  }
}

export function withReauth<T extends JSX.IntrinsicAttributes>(
  Component: React.ComponentType<T>,
  redirectTo = '/account/reauthenticate',
  Fallback: React.ReactNode = <div>Memuat halaman aman...</div>
) {
  return function Wrapped(props: T) {
    const { isAuthenticated, loading } = useAuth()
    const router = useRouter()
    const pathname = usePathname()
    const searchParams = useSearchParams()

    const isValidReauth = useRecentlyReauthenticated()

    const isOnReauthPage = pathname.startsWith(redirectTo)

    // Buat URL lengkap termasuk query string (jika ada)
    const currentPath =
      pathname + (searchParams.toString() ? `?${searchParams.toString()}` : '')

    useEffect(() => {
      // ✅ Jika user login tapi belum reauth (dan bukan di halaman reauth), redirect
      if (!loading && isAuthenticated && !isValidReauth && !isOnReauthPage) {
        const next = searchParams.get('next') || currentPath
        router.replace(`${redirectTo}?next=${encodeURIComponent(next)}`)
      }
    }, [
      loading,
      isAuthenticated,
      isValidReauth,
      isOnReauthPage,
      searchParams,
      currentPath,
      router,
    ])

    // ⏳ Tampilkan fallback jika belum siap
    if (loading || !isAuthenticated || (!isValidReauth && !isOnReauthPage)) {
      return <>{Fallback}</>
    }

    return <Component {...props} />
  }
}


----------------------------------------

