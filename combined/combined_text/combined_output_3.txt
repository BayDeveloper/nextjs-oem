
-- /nextjs_oem_frontend/src/lib/hooks/useSessions.ts --
// lib/hooks/useSessions.ts
import useSWR from 'swr'
import { getSessions } from '../allauth'

export function useSessions() {
  return useSWR('/auth/sessions', async () => await getSessions(), {
    revalidateOnFocus: true
  })
}


----------------------------------------


-- /nextjs_oem_frontend/src/lib/hooks/useAuthConfig.ts --
// lib/hooks/useAuthConfig.ts
import useSWR from 'swr'
import { getConfig, ConfigResponse } from '../allauth'

export function useAuthConfig() {
  return useSWR<ConfigResponse>('/auth/config', getConfig, {
    revalidateOnFocus: false,
    dedupingInterval: 5 * 60 * 1000,
  })
}


----------------------------------------


-- /nextjs_oem_frontend/src/lib/hooks/useInvitation.ts --
// src/lib/hooks/useInvitation.ts
import { useState, useCallback } from 'react';
import * as API from '../../lib/allauth';

export interface InvitationValidationResponse {
  id: number;
  email: string;
  token: string;
  expires_at: string;
  used: boolean;
  [key: string]: any;
}

export function useInvitation() {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const sendEmailRequest = useCallback(async (email: string) => {
    setLoading(true);
    setError(null);
    try {
      return await API.submitEmailRequest(email);
    } catch (e: any) {
      setError(e.data?.detail || e.message);
      return undefined;
    } finally {
      setLoading(false);
    }
  }, []);

  const validateToken = useCallback(async (token: string): Promise<InvitationValidationResponse | undefined> => {
    setLoading(true);
    setError(null);
    try {
      return await API.validateToken(token);
    } catch (e: any) {
      setError(e.data?.detail || e.message);
      return undefined;
    } finally {
      setLoading(false);
    }
  }, []);

  // 2) Signup dengan invitation
  const signupWithToken = useCallback(async ({
    email, password1, password2, token
  }: {
    email: string;
    password1: string;
    password2: string;
    token: string;
  }) => {
    setLoading(true); setError(null);
    try {
      // a) Panggil endpoint headless signup
      const signupResp = await API.registerWithInvitation({ email, password1, password2, token });
      // b) Jika signup berhasil, tandai token sebagai used
      if (signupResp && signupResp.detail) {
        await API.useInvitation(signupResp.id);   // atau panggil useInvitation(validateResp.id)
      }
      return signupResp;
    } catch (e: any) {
      setError(e.data?.detail || e.message);
      return undefined;
    } finally {
      setLoading(false);
    }
  }, []);

  return {
    loading,
    error,
    sendEmailRequest,
    validateToken,
    signupWithToken,
  };
}


----------------------------------------


-- /nextjs_oem_frontend/src/lib/hooks/useProviderAccounts.ts --
// lib/hooks/useProviderAccounts.ts
import useSWR from 'swr'
import { getProviderAccounts } from '../allauth'

export function useProviderAccounts() {
  return useSWR('/account/provider', getProviderAccounts)
}


----------------------------------------


-- /nextjs_oem_frontend/src/lib/hooks/useEmailAddresses.ts --
// lib/hooks/useEmailAddresses.ts
import useSWR from 'swr'
import { getEmailAddresses } from '../allauth'

export function useEmailAddresses() {
  return useSWR('/auth/email', getEmailAddresses)
}


----------------------------------------


-- /nextjs_oem_frontend/src/lib/helpers/ClientOnly.tsx --
// lib/helpers/ClientOnly.tsx
'use client'

import React, { useEffect, useState } from 'react'

export function ClientOnly({ children }: { children: React.ReactNode }) {
  const [hasMounted, setHasMounted] = useState(false)

  useEffect(() => {
    setHasMounted(true)
  }, [])

  if (!hasMounted) return null
  return <>{children}</>
}


----------------------------------------


-- /nextjs_oem_frontend/src/lib/helpers/withSafeRender.tsx --
// === src/lib/helpers/withSafeRender.tsx ===
'use client'

import React, { JSX } from 'react'

/**
 * HOC untuk menunda render komponen sampai kondisi isReady() terpenuhi.
 * @param Component Komponen React yang ingin dibungkus.
 * @param isReady   Fungsi yang mengembalikan boolean; render hanya ketika true.
 * @param Fallback  Konten yang dirender sementara isReady() masih false.
 */
export function withSafeRender<T extends JSX.IntrinsicAttributes>(
  Component: React.ComponentType<T>,
  isReady: () => boolean,
  Fallback: React.ReactNode = <p>Memuat...</p>
) {
  return function WrappedComponent(props: T) {
    // Jika belum siap, tampilkan fallback
    if (!isReady()) {
      return <>{Fallback} </>
    }
    // Setelah siap, render komponen utama
    return <Component {...props} />
  }
}


----------------------------------------

