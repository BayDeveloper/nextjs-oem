
-- /nextjs_oem_frontend/src/lib/helpers/useRequest.ts --
// lib/helpers/useRequest.ts
import { useState, useCallback } from 'react';

type RequestFn<T, A extends unknown[]> = (...args: A) => Promise<T>;

// K: tipe ID bisa number atau string tergantung kebutuhan
export function useRequest<
  T,
  A extends unknown[] = unknown[],
  K extends number | string = number
>(
  fn: RequestFn<T, A>,
  options?: { idIndex?: number } // index argumen yang mengandung ID
) {
  const [error, setError] = useState<string | null>(null);
  const [loadingId, setLoadingId] = useState<K | null>(null);

  const trigger = useCallback(
    async (...args: A): Promise<T | null> => {
      setError(null);

      // Tangkap ID dari argumen kalau ada
      if (typeof options?.idIndex === 'number') {
        const maybeId = args[options.idIndex] as K;
        if (maybeId !== undefined) {
          setLoadingId(maybeId);
        }
      } else {
        // fallback: pakai 'GLOBAL' sebagai indikator loading umum
        setLoadingId('GLOBAL' as K);
      }

      try {
        const resp = await fn(...args);
        return resp;
      } catch (err) {
        const e = err as { message?: string; data?: { detail?: string } };
        const msg =
          e?.data?.detail ||
          e?.message ||
          'Terjadi kesalahan. Coba lagi nanti.';
        setError(msg);
        return null;
      } finally {
        setLoadingId(null);
      }
    },
    [fn, options?.idIndex]
  );

  return { trigger, error, loadingId };
}


----------------------------------------


-- /nextjs_oem_frontend/src/auth/useLogout.ts --
'use client'

import { useCallback, useState, useEffect } from 'react'
import { fetchCSRFToken, logout } from '../lib/allauth'
import { useAuth } from './AuthContext'
import { useRouter } from 'next/navigation'
import { mutate } from 'swr'

type LogoutError = {
  status?: number
  [key: string]: unknown
}

export function useLogout(redirectTo: string = '/account/login') {
  const [logoutRequested, setLogoutRequested] = useState(false)
  const { isAuthenticated, loading } = useAuth()
  const router = useRouter()

  const triggerLogout = useCallback(async () => {
    try {
      await fetchCSRFToken()
      await logout()
    } catch (err: unknown) {
      const error = err as LogoutError
      if (error.status !== 401) {
        console.error('Logout error:', error)
      }
    } finally {
      await mutate('/auth/session', null, false)
      setLogoutRequested(true)
    }
  }, [])

  useEffect(() => {
    if (!loading && !isAuthenticated && logoutRequested) {
      router.replace(redirectTo)
    }
  }, [loading, isAuthenticated, logoutRequested, router, redirectTo])

  return { triggerLogout, logoutRequested }
}


----------------------------------------


-- /nextjs_oem_frontend/src/auth/useCSRF.ts --
// src/auth/useCSRF.ts
"use client";

import useSWR from "swr";

// Gunakan fetcher default dari SWRConfig
export function useCSRF() {
  return useSWR(
    "/_allauth/browser/v1/auth/csrf",
    (url: string) => fetch(url, { credentials: "include" }),  // hanya perlu fetch saja
    {
      revalidateOnFocus: false,
      dedupingInterval: 5 * 60 * 1000,  // satu kali fetch tiap 5 menit
    }
  );
}


----------------------------------------


-- /nextjs_oem_frontend/src/auth/routing.ts --
// auth/routing.ts
import { AuthenticatorType, AuthResponse, Flows } from "../lib/allauth";

const flow2path: Record<string, string> = {
  [Flows.LOGIN]: '/account/login',
  [Flows.LOGIN_BY_CODE]: '/account/login/code/confirm',
  [Flows.SIGNUP]: '/account/signup',
  [Flows.VERIFY_EMAIL]: '/account/verify-email',
  [Flows.PASSWORD_RESET_BY_CODE]: '/account/password/reset/confirm',
  [Flows.PROVIDER_SIGNUP]: '/account/provider/signup',
  [Flows.REAUTHENTICATE]: '/account/reauthenticate',
  [Flows.MFA_TRUST]: '/account/2fa/trust',
  [`${Flows.MFA_AUTHENTICATE}:${AuthenticatorType.TOTP}`]: '/account/authenticate/totp',
  [`${Flows.MFA_AUTHENTICATE}:${AuthenticatorType.RECOVERY_CODES}`]: '/account/authenticate/recovery-codes',
  [`${Flows.MFA_AUTHENTICATE}:${AuthenticatorType.WEBAUTHN}`]: '/account/authenticate/webauthn',
  [`${Flows.MFA_REAUTHENTICATE}:${AuthenticatorType.TOTP}`]: '/account/reauthenticate/totp',
  [`${Flows.MFA_REAUTHENTICATE}:${AuthenticatorType.RECOVERY_CODES}`]: '/account/reauthenticate/recovery-codes',
  [`${Flows.MFA_REAUTHENTICATE}:${AuthenticatorType.WEBAUTHN}`]: '/account/reauthenticate/webauthn',
  [Flows.MFA_WEBAUTHN_SIGNUP]: '/account/signup/passkey/create',
}

type FlowType = {
  id: string
  types?: string[]
  is_pending?: boolean
}

export function pathForFlow(flow: FlowType, typ?: string): string {
  let key = flow.id
  if (typeof flow.types !== 'undefined') {
    typ = typ ?? flow.types[0]
    key = `${key}:${typ}`
  }
  const path = flow2path[key] ?? flow2path[flow.id]
  if (!path) {
    throw new Error(`Unknown path for flow: ${flow.id}`)
  }
  return path
}

export function pathForPendingFlow(auth?: AuthResponse | null): string | null {
  const flow = auth?.data?.flows?.find((f): f is FlowType => !!f?.is_pending)
  return flow ? pathForFlow(flow, undefined) : null
}


----------------------------------------

